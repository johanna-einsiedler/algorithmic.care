import { createHash } from "node:crypto";
import { accessSync, constants, readFileSync, statSync } from "node:fs";
import { join } from "node:path/posix";
import { resolvePath } from "../path.js";
import { findFiles } from "./files.js";
import { findImports } from "./imports.js";
import { parseProgram } from "./parse.js";
const fileInfoCache = /* @__PURE__ */ new Map();
const moduleInfoCache = /* @__PURE__ */ new Map();
function getModuleHash(root, path) {
  const hash = createHash("sha256");
  const paths = /* @__PURE__ */ new Set([path]);
  for (const path2 of paths) {
    const info = getModuleInfo(root, path2);
    if (!info)
      continue;
    hash.update(info.hash);
    for (const i of info.localStaticImports) {
      paths.add(resolvePath(path2, i));
    }
    for (const i of info.localDynamicImports) {
      paths.add(resolvePath(path2, i));
    }
    for (const i of info.files) {
      const f = getFileInfo(root, resolvePath(path2, i));
      if (!f)
        continue;
      hash.update(f.hash);
    }
  }
  return hash.digest("hex");
}
function getModuleInfo(root, path) {
  const key = join(root, path);
  let mtimeMs;
  try {
    ({ mtimeMs } = statSync(key));
  } catch {
    moduleInfoCache.delete(key);
    return;
  }
  let info = moduleInfoCache.get(key);
  if (!info || info.mtimeMs < mtimeMs) {
    let source;
    let body;
    try {
      source = readFileSync(key, "utf-8");
      body = parseProgram(source);
    } catch {
      moduleInfoCache.delete(key);
      return;
    }
    const hash = createHash("sha256").update(source).digest("hex");
    const imports = findImports(body, path, source);
    const files = findFiles(body, path, source);
    const localStaticImports = /* @__PURE__ */ new Set();
    const localDynamicImports = /* @__PURE__ */ new Set();
    const globalStaticImports = /* @__PURE__ */ new Set();
    const globalDynamicImports = /* @__PURE__ */ new Set();
    for (const i of imports) {
      (i.type === "local" ? i.method === "static" ? localStaticImports : localDynamicImports : i.method === "static" ? globalStaticImports : globalDynamicImports).add(i.name);
    }
    moduleInfoCache.set(
      key,
      info = {
        mtimeMs,
        hash,
        files: new Set(files.map((f) => f.name)),
        fileMethods: new Set(files.map((f) => f.method).filter((m) => m !== void 0)),
        localStaticImports,
        localDynamicImports,
        globalStaticImports,
        globalDynamicImports
      }
    );
  }
  return info;
}
function getFileHash(root, path) {
  return getFileInfo(root, path)?.hash ?? createHash("sha256").digest("hex");
}
function getFileInfo(root, path) {
  const key = join(root, path);
  let mtimeMs;
  try {
    const stat = statSync(key);
    if (!stat.isFile())
      return;
    accessSync(key, constants.R_OK);
    ({ mtimeMs } = stat);
  } catch {
    fileInfoCache.delete(key);
    return;
  }
  let entry = fileInfoCache.get(key);
  if (!entry || entry.mtimeMs < mtimeMs) {
    const contents = readFileSync(key);
    const hash = createHash("sha256").update(contents).digest("hex");
    fileInfoCache.set(key, entry = { mtimeMs, hash });
  }
  return entry;
}
export {
  getFileHash,
  getFileInfo,
  getModuleHash,
  getModuleInfo
};
