import { Runtime } from "observablehq:runtime";
import { FileAttachment, Generators, Mutable, resize } from "observablehq:stdlib";
import { inspect, inspectError } from "./inspect.js";
import * as recommendedLibraries from "./stdlib/recommendedLibraries.js";
import * as sampleDatasets from "./stdlib/sampleDatasets.js";
const library = {
  now: () => Generators.now(),
  width: () => Generators.width(document.querySelector("main")),
  dark: () => Generators.dark(),
  resize: () => resize,
  FileAttachment: () => FileAttachment,
  Generators: () => Generators,
  Mutable: () => Mutable,
  ...recommendedLibraries,
  ...sampleDatasets
};
const runtime = new Runtime(library);
const main = runtime.module();
const cellsById = /* @__PURE__ */ new Map();
function define(cell) {
  const { id, inline, inputs = [], outputs = [], body } = cell;
  const variables = [];
  cellsById.get(id)?.variables.forEach((v2) => v2.delete());
  cellsById.set(id, { cell, variables });
  const root = document.querySelector(`#cell-${id}`);
  const loading = root.querySelector(".observablehq-loading");
  const pending = () => reset(root, loading);
  const rejected = (error) => reject(root, error);
  const v = main.variable({ _node: root, pending, rejected }, { shadow: {} });
  if (inputs.includes("display") || inputs.includes("view")) {
    let displayVersion = -1;
    const display = inline ? displayInline : displayBlock;
    const vd = new v.constructor(2, v._module);
    vd.define(
      inputs.filter((i) => i !== "display" && i !== "view"),
      () => {
        let version = v._version;
        return (value) => {
          if (version < displayVersion)
            throw new Error("stale display");
          else if (version > displayVersion)
            clear(root);
          displayVersion = version;
          display(root, value);
          return value;
        };
      }
    );
    v._shadow.set("display", vd);
    if (inputs.includes("view")) {
      const vv = new v.constructor(2, v._module, null, { shadow: {} });
      vv._shadow.set("display", vd);
      vv.define(["display"], (display2) => (v2) => Generators.input(display2(v2)));
      v._shadow.set("view", vv);
    }
  }
  v.define(outputs.length ? `cell ${id}` : null, inputs, body);
  variables.push(v);
  for (const o of outputs)
    variables.push(main.variable(true).define(o, [`cell ${id}`], (exports) => exports[o]));
}
function reset(root, loading) {
  if (root.classList.contains("observablehq--error")) {
    root.classList.remove("observablehq--error");
    clear(root);
    if (loading)
      root.append(loading);
  }
}
function reject(root, error) {
  console.error(error);
  root.classList.add("observablehq--error");
  clear(root);
  root.append(inspectError(error));
}
function clear(root) {
  root.textContent = "";
}
function displayInline(root, value) {
  if (isNode(value) || typeof value === "string" || !value?.[Symbol.iterator])
    root.append(value);
  else
    root.append(...value);
}
function displayBlock(root, value) {
  root.append(isNode(value) ? value : inspect(value));
}
function undefine(id) {
  cellsById.get(id)?.variables.forEach((v) => v.delete());
  cellsById.delete(id);
}
function isNode(value) {
  return value instanceof Node && value instanceof value.constructor;
}
export {
  define,
  main,
  runtime,
  undefine
};
